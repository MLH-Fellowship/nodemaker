import { execSync as exec } from "child_process"; // sync to facilitate subsequent verification
import { join } from "path";
import Generator from "./Generator";
import { NodeGenerationEnum, AuthEnum } from "../utils/enums";
import readdir from "../utils/readdir";

/**Responsible for generating all node functionality files at `/output`:
 * - `*.node.ts`
 * - `GenericFunctions.ts`
 * - `.credentials.ts`
 * - one or more `*Description.ts` files (in complex node generation)
 */
export default class NodeFilesGenerator extends Generator {
  private mainParameters: MainParameters;
  private metaParameters: MetaParameters;
  private nodeGenerationType: NodeGenerationType;

  constructor(paramsBundle: ParamsBundle) {
    super();
    this.mainParameters = paramsBundle.mainParameters;
    this.metaParameters = paramsBundle.metaParameters;
    this.nodeGenerationType = paramsBundle.nodeGenerationType;
  }

  /**Generate node functionality files.*/
  async run(): Promise<NodemakerResult> {
    this.generateMainNodeFile();
    this.generateGenericFunctionsFile();

    if (this.nodeGenerationType === NodeGenerationEnum.Complex)
      this.generateResourceDescriptionFile();

    if (this.metaParameters.authType !== AuthEnum.None)
      this.generateCredentialsFile();

    try {
      await this.verifyGeneratedFiles();
      return { error: false };
    } catch (thrownError) {
      return { error: true, errorMessage: thrownError };
    }
  }

  /**Generate `*.node.ts`, with a different version for simple or complex node generation.*/
  private generateMainNodeFile() {
    const command = this.formatCommand(`
    gen generateNode${this.nodeGenerationType}
      --name \"${this.metaParameters.serviceName}\"
      --metaParameters '${JSON.stringify(this.metaParameters)}'
      --mainParameters '${JSON.stringify(this.mainParameters)}'
    `);
    exec(command);
  }

  /**Generate `GenericFunctions.ts`.*/
  private generateGenericFunctionsFile() {
    const command = this.formatCommand(`
    gen generateGenericFunctions
      --metaParameters '${JSON.stringify(this.metaParameters)}'
      --mainParameters '${JSON.stringify(this.mainParameters)}'
    `);

    exec(command);
  }

  /**Generate `*.credentials.ts` for OAuth2 or API Key.*/
  private generateCredentialsFile() {
    const command = this.formatCommand(`
    gen generate${this.metaParameters.authType}Credential
      --name \"${this.metaParameters.serviceName}\"
      --serviceCredential ${this.deriveServiceCredentialName()}
    `);

    exec(command);
  }

  /** In complex node generation, generate one additional file per resource.*/
  private generateResourceDescriptionFile() {
    for (let resourceName in this.mainParameters) {
      const command = this.formatCommand(`
      gen generateResourceDescription
        --resourceName ${resourceName}
        --resourceObject '${JSON.stringify(this.mainParameters[resourceName])}'
      `);

      exec(command);
    }
  }

  /**Verify if the 2 to 4 files that are to be generated by from `generateNodeFiles` were actually generated.*/
  private async verifyGeneratedFiles() {
    const files = await readdir(join("output"));

    const wasGenerated = (snippet: string) =>
      files.some((file) => file.endsWith(snippet));

    const filesToBeVerified = [".node.ts", "GenericFunctions.ts"];

    if (this.nodeGenerationType === NodeGenerationEnum.Complex)
      filesToBeVerified.push("Description.ts");

    if (this.metaParameters.authType === AuthEnum.OAuth2)
      filesToBeVerified.push("OAuth2Api.credentials.ts");

    filesToBeVerified.forEach((file) => {
      if (!wasGenerated(file)) {
        throw Error("Generation failed for file: " + file);
      }
    });
  }
}
